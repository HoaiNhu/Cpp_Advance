Tên mảng (chính là biến arr trong bài này) mà từ trước tới nay bạn sử dụng có bản chất giống như một con trỏ. Để hiểu rõ hơn bạn có thể xem ví dụ sau:

#include <iostream>

using namespace std;

int main() {
    int arr[] = { 1, 2, 3, 4, 5 };
    // Hiển thị giá trị của arr
    cout << arr << endl;
    // Hiển thị địa chỉ của phần tử đầu tiên trong mảng
    cout << &arr[0];
    return 0;
}
Kết quả khi chạy chương trình

0039FA9C
0039FA9C
Có thể thấy giá trị của arr chính là địa chỉ của phần tử đầu tiên trong mảng (arr trỏ tới địa chỉ của arr[0]), nên có thể coi arr giống như 1 con trỏ.

Lưu ý: arr không phải là một con trỏ mà arr được dùng giống như một con trỏ.

Bạn có thể duyệt mảng bằng biến arr mà biến arr giống như một con trỏ nên bạn cũng có thể duyệt mảng bằng 1 con trỏ. Xem ví dụ sau:

#include <iostream>

using namespace std;

int main() {
    int arr[] = { 1, 2, 3, 4, 5 };
    int* p = &arr[0];
    for (int i = 0; i < 5; i++) {
        cout << p[i] << " ";
    }
    return 0;
}
Kết quả khi chạy chương trình:

1 2 3 4 5

------------------------------------------------------------
Mảng là một tập các phần tử được nằm trên các ô nhớ liên tiếp. Do đó địa chỉ của các phần tử trong mảng cũng liên tiếp nhau. Để hiểu rõ hơn bạn có thể xem chương trình sau:

#include <iostream>

using namespace std;

int main() {
	int arr[] = { 1, 2, 3, 4, 5 };
	for (int i = 0; i < 5; i++) {
		cout << (int)&arr[i] << " ";
	}
	return 0;
}
Kết quả khi chạy chương trình:

17824096 17824100 17824104 17824108 17824112
Kết quả khi chạy trên máy bạn sẽ khác nhưng nếu để ý thì bạn có thể thấy địa chỉ của các phần tử liên tiếp trong mảng luôn cách nhau 4 đơn vị (do kích thước của kiểu int là 4 byte nên 1 biến kiểu int sẽ cần dùng tới 4 ô nhớ để lưu dữ liệu)



Bạn hãy xem một ví dụ khác để hiểu rõ hơn:

#include <iostream>

using namespace std;

int main() {
	char arr[] = { 'a', 'b', 'c', 'd', 'e' };
	for (int i = 0; i < 5; i++) {
		cout << (int)&arr[i] << " ";
	}
	return 0;
}
Kết quả khi chạy chương trình:

12057624 12057625 12057626 12057627 12057628
Có thể thấy địa chỉ của các phần tử trong mảng cách nhau đúng 1 đơn vị (do kiểu char có kích thước là 1 byte nên chỉ cần 1 ô nhớ để lưu trữ dữ liệu).
------------------------------------------------------------
Để làm bài này bạn cần hiểu về toán tử + trên con trỏ. Đầu tiên bạn hãy chạy thử chương trình sau:

#include <iostream>

using namespace std;

int main() {
    // Khai báo mảng arr với 5 phần tử
    int arr[] = { 1, 2, 3, 4, 5 };
    // Cho con trỏ p trỏ tới phần tử đầu tiên của mảng
    int* p = &arr[0];
    // Hiển thị địa chỉ của phần tử đầu tiên trong arr
    cout << (int)&arr[0] << endl;
    for (int i = 0; i < 5; i++) {
        // Hiển thị giá trị khi cộng con trỏ p với i
        cout << (int)(p + i) << " ";
    }
    return 0;
}
Kết quả khi chạy chương trình:

3799772
3799772 3799776 3799780 3799784 3799788
Từ kết quả trên có thể nhận xét rằng:

Kết quả của phép cộng một con trỏ với 1 giá trị là 1 con trỏ trỏ tới ô nhớ khác (p trỏ tới ô nhớ 3799772, p + 1 trỏ tới ô nhớ 3799776).
p + 1 trỏ tới ô nhớ cách ô nhớ mà p trỏ tới 4 địa chỉ (do p là con trỏ kiểu int và kích thước của kiểu int là 4 byte).
p + 2 trỏ tới ô nhớ cách ô nhớ mà p trỏ tới 8 địa chỉ.
p + 3 trỏ tới ô nhớ cách ô nhớ mà p trỏ tới 12 địa chỉ.
p + 4 trỏ tới ô nhớ cách ô nhớ mà p trỏ tới 16 địa chỉ.
Như bài trước bạn đã được học, địa chỉ của các phần tử liên tiếp trong mảng số nguyên luôn cách nhau 4 đơn vị nên bạn cũng có thể duyệt mảng sử dụng con trỏ với toán tử + như sau:

#include <iostream>

using namespace std;

int main() {
    int arr[] = { 1, 2, 3, 4, 5 };
    int* p = &arr[0];
    for (int i = 0; i < 5; i++) {
        cout << *(p + i) << " ";
    }
    return 0;
}
Kết quả khi chạy chương trình

1 2 3 4 5
Có thể thấy khi cộng con trỏ với 1 giá_trị thì kết quả sẽ là một con trỏ trỏ tới ô nhớ cách đó sizeof(kiểu_con_trỏ) * giá_trị. Xem ví dụ với con trỏ kiểu double* để hiểu rõ hơn:

#include <iostream>

using namespace std;

int main() {
    double arr[] = { 1.5, 2.5, 3.5, 4.5, 5.5 };
    double* p = &arr[0]; // Bạn còn có thể viết double * p = arr;
    for (int i = 0; i < 5; i++) {
        cout << (int)(p + i) << " ";
    }
    return 0;
}
Kết quả khi chạy chương trình:

9895220 9895228 9895236 9895244 9895252
Có thể thấy p + 1 cách p 8 địa chỉ, p + 2 cách p 16 địa chỉ, ... (do sizeof(double) = 8)

-----------------------------------------------------------------------------------------
Trước hết bạn hãy xem lại cách khai báo mảng thông thường:

// Khai báo mảng a 100 phần tử
int arr[100];
Nhược điểm:

Với cách khai báo này số phần tử của mảng luôn phải cố định, bạn không thể thay đổi kích thước của mảng khi chương trình đang chạy. Ví dụ vì lý do nào đó mà sau này mảng arr cần tới 101 phần tử thì bạn chỉ có cách tắt chương trình đi và code lại thành int arr[101]; (do mảng không tự tăng kích thước được).
Mảng sẽ được cấp phát trên vùng nhớ Stack, và kích thước của vùng nhớ này là nhỏ nên bạn không thể khai báo mảng có nhiều phần tử được. Ví dụ bạn hãy thử chạy chương trình sau:
#include <iostream>

using namespace std;

int main() {
    int arr[10000000];
    return 0;
}
​
Chương trình này sẽ báo lỗi do kích thước của vùng nhớ Stack không đủ để cấp phát bộ nhớ cho mảng a.

Ưu điểm:

Mảng được cấp phát trên vùng nhớ Stack nên sẽ có tốc độ truy xuất nhanh (vùng nhớ stack tuy có kích thước nhỏ nhưng lại có tốc độ truy xuất nhanh hơn các vùng nhớ khác).
Bộ nhớ được chương trình quản lý tự động (vùng nhớ được cấp phát cho mảng sẽ được chương trình giải phóng khi không dùng nữa).
Mảng được cấp phát động sẽ giải quyết được những nhược điểm trên nhưng cũng có một số nhược điểm. Trước hết bạn hãy xem cách để cấp phát bộ nhớ động cho mảng:

// Cấp phát bộ nhớ động cho mảng có 10000000 phần tử
// Để cấp phát bộ nhớ động cho mảng ta sử dụng toán tử new
int* arr = new int[10000000];
Đoạn code trên cấp phát bộ nhớ động cho mảng có 10000000 phần tử, lưu ý rằng arr không phải là một mảng, arr là một con trỏ trỏ tới vùng nhớ được cấp phát động (trỏ tới phần tử đầu tiên của mảng được cấp phát động) hay hiểu cách khác arr là con trỏ dùng để quản lý mảng có 10000000 phần tử.

Bạn có thể sử dụng mảng được cấp phát động giống như mảng thông thường:

#include <iostream>

using namespace std;

int main() {
    // Cấp phát động cho mảng có 10 phần tử
    int* arr = new int[10];
    for (int i = 0; i < 10; i++) {
        arr[i] = i;
    }
    for (int i = 0; i < 10; i++) {
        cout << arr[i] << " ";
    }
    // Giải phóng bộ nhớ được cấp phát động khi không sử dụng
    delete[]arr;
    return 0;
}
Kết quả khi chạy chương trình:

0 1 2 3 4 5 6 7 8 9
Ưu điểm của cấp phát bộ nhớ động

Số phần tử của mảng không nhất thiết phải cố định. Ví dụ:
#include <iostream>

using namespace std;

int main() {
    int n;
    cin >> n;
    // Cấp phát động cho mảng có n phần tử
    int* arr = new int[n];
    // Giải phóng bộ nhớ được cấp phát động khi không sử dụng
    delete[]arr;
    return 0;
}
​​
Có thể thấy trong ví dụ trên số phần tử của mảng được cấp phát động là một biến được nhập từ bàn phím.

Bạn có thể thay đổi kích thước mảng khi chương trình đang chạy (bản chất là cho con trỏ tới vùng nhớ khác, ví dụ nếu bạn cần tăng kích thước của mảng thì bạn chỉ cần cho con trỏ trỏ tới vùng nhớ có kích thước lớn hơn).
Mảng được cấp phát trên vùng nhớ Heap mà vùng nhớ Heap là vùng nhớ có kích thước lớn nhất trong các vùng nhớ nên với cấp phát động bạn có thể khai báo mảng với nhiều phần tử. Ví dụ:
#include <iostream>

using namespace std;

int main() {
    int* arr = new int[10000000];
    // Giải phóng bộ nhớ được cấp phát động khi không sử dụng
    delete[]arr;
    return 0;
}
​
Chương trình này khi chạy sẽ không báo lỗi do vùng nhớ Heap có kích thước lớn và có thể lưu trữ được mảng có 10000000 phần tử.
Nhược điểm của cấp phát bộ nhớ động

Vùng nhớ Heap có tốc độ truy xuất chậm hơn vùng nhớ Stack nên việc truy xuất vào các phần tử trong mảng được cấp phát động sẽ chậm hơn.
Bạn phải tự quản lý bộ nhớ được cấp phát động (chương trình sẽ không quản lý cho bạn). Nếu bạn thực hiện cấp phát bộ nhớ động mà không giải phóng thì vùng nhớ này sẽ vẫn còn cho tới khi khởi động lại máy (gây lãng phí bộ nhớ, tệ hơn nữa là tràn bộ nhớ).
Để giải phóng bộ nhớ được cấp phát động bạn dùng toán tử delete[]. Ví dụ:

#include <iostream>

using namespace std;

int main() {
	// Cấp phát bộ nhớ động cho mảng có 1000 phần tử
	int* arr = new int[1000];
	...
	// Giải phòng bộ nhớ khi không dùng tới
	delete[] arr;
	return 0;
}
​​
Do đó khi cấp phát động hãy luôn nhớ phải dùng toán tử delete[] để giải phóng bộ nhớ khi không dùng tới nữa.

Lỗi thường gặp khi cấp phát bộ nhớ động:

#include<iostream>

using namespace std;

int main() {
	int* arr = new int[1000];
	arr = new int[2000];
	delete[]arr;
	return 0;
}
Đoạn code trên sẽ gây ra rò rỉ bộ nhớ do khi gán arr = new int[2000]; thì vùng nhớ được cấp phát động cho mảng có 1000 phần tử vẫn còn đó, bạn cần giải phóng vùng nhớ này trước khi cho arr trỏ tới vùng nhớ mới giống như sau:

#include<iostream>

using namespace std;

int main() {
	int* arr = new int[1000];
	delete[]arr;
	arr = new int[2000];
	delete[]arr;
	return 0;
}
--------------------------------------------------------------------------
Cấp phát bộ nhớ tĩnh

Dùng để cấp phát bộ nhớ cho các biến toàn cục, các biến được khai báo với từ khóa static.
Dữ liệu được cấp phát sẽ nằm trên Data Segment.
Vùng nhớ của biến được cấp phát ngay khi chương trình chạy.
Kích thước của vùng nhớ phải được cung cấp tại thời điểm biên dịch, và đó cũng là lý do vì sao khi khai báo mảng bạn luôn phải khai báo số phần tử của mảng là một hằng số.
// Sai
int a[n];

// Đúng
int a[100];
Ví dụ về mảng được cấp phát bộ nhớ tĩnh:
#include <iostream> 

using namespace std;

// Mảng arr được cấp phát tĩnh
int arr[100];

int main() {

    return 0;
}​
Cấp phát bộ nhớ tự động

Dùng để cấp phát bộ nhớ cho biến cục bộ.
Kích thước của vùng nhớ phải được cung cấp tại thời điểm biên dịch (giống với cấp phát bộ nhớ tĩnh) nên nếu khai báo mảng, bạn vẫn phải khai báo số phần tử là một hằng số.
Dữ liệu được được cấp phát sẽ nằm trên Stack Segment.
Ví dụ về mảng được cấp phát tự động:
#include <iostream> 

using namespace std;


int main() {
    // Mảng arr được cấp phát bộ nhớ tự động
    int arr[100];

    return 0;
}​
Nhược điểm của 2 loại cấp phát trên

Không thể thay đổi số phần tử của mảng sau khi chương trình đã chạy, bạn chỉ có cách tắt chương trình đi và viết lại code.
Không thể cấp phát được nhiều bộ nhớ như cấp phát động,nhất là cấp phát bộ nhớ tự động (do kích thước stack segment nhỏ).
Ưu điểm của 2 loại cấp phát trên

Truy xuất dữ liệu nhanh.
Bộ nhớ được chương trình quản lý tự động.
Lưu ý: ở 1 số trình biên dịch cho phép bạn khai báo mảng mà không cần biết trước số phần tử của mảng giống như sau:

#include <iostream>

int main()
{
    int n;
    cin >> n;
    int arr[n];
    return 0;
}
Nếu bạn đang sử dụng trình biên dịch có hỗ trợ VLA (Variable Length Arrays) thì đoạn code trên sẽ chạy mà không báo lỗi. Tuy nhiên, đây không phải là cú pháp chuẩn của C++, và nó sẽ không chạy được trên các trình biên dịch không hỗ trợ VLA (đoạn code trên sẽ báo lỗi nếu bạn chạy trên trình biên dịch MSVC của Visual studio). Do đó, bạn nên hạn chế tối đa việc viết code giống như trên.

Cấp phát bộ nhớ động (Dynamic Memory Allocation)

Kích thước bộ nhớ sẽ được cấp phát khi chương trình đang chạy.
Dữ liệu được cấp phát sẽ nằm trên Heap Segment
Bạn phải tự quản lý bộ nhớ.
Ưu điểm của cấp phát bộ nhớ động

Heap segment có dung lượng bộ nhớ lớn nhất nên sẽ cấp phát được nhiều bộ nhớ hơn.
Bạn có thể thay đổi kích thước mảng khi chương trình đang chạy.
Nhược điểm của cấp phát động:

Truy xuất tới vùng nhớ được cấp phát động sẽ chậm hơn so với cấp phát tĩnh và cấp phát tự động.
Bạn phải tự quản lý bộ nhớ thay vì được chương trình quản lý hộ. Do đó nếu không cẩn thận sẽ rất dễ bị tràn bộ nhớ.
Cả 3 loại cấp phát này đều có ưu điểm và nhược điểm nên không thể nói loại nào là tốt hơn mà phải tùy vào từng trường hợp cụ thể.
--------------------------------------------------------------------------------------------------------------------------------------
Mảng 2 chiều là mảng các mảng 1 chiều, và mảng 2 chiều cũng có tính chất giống mảng 1 chiều là các phần tử trong mảng được nằm trong các ô nhớ liên tiếp nhau. Để hiểu rõ hơn bạn hãy xem ví dụ sau:

#include<iostream>

using namespace std;

int main() {
	char arr[4][4];
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			cout << (int)&arr[i][j] << endl;
		}
	}
	return 0;
}
Kết quả khi chạy chương trình:

19920928
19920929
19920930
19920931
19920932
19920933
19920934
19920935
19920936
19920937
19920938
19920939
19920940
19920941
19920942
19920943
Có thể thấy địa chỉ của các phần tử trong mảng là liên tiếp nhau, vậy bản chất mảng 2 chiều được lưu trữ trên bộ nhớ như là mảng một chiều. Do đó, bạn có thể truy xuất tới các phần tử trong mảng 2 chiều giống như mảng 1 chiều. Ví dụ chương trình sau:

#include<iostream>

using namespace std;

int main() {
	int arr[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
	int* p = &arr[0][0];
	for (int i = 0; i < 9; i++) {
		cout << p[i] << " ";
	}
	return 0;
}
Kết quả khi chạy chương trình:

1 2 3 4 5 6 7 8 9
Có thể thấy mảng 2 chiều có thể sử dụng giống như 1 mảng một chiều. Do đó bài này bạn cũng có thể làm bằng cách cấp phát bộ nhớ động cho mảng 1 chiều và sử dụng mảng 1 chiều này như là mảng 2 chiều.

Vậy chương trình trên có thể làm bằng mảng 1 chiều giống như sau:

#include<iostream>

using namespace std;

int main() {
	int n, m;
	cin >> n >> m;
	int* arr = new int[n * m];
	
	for (int i = 0; i < n * m; i++) {
		cin >> arr[i];
	}

	int index = 0;
	for (int i = 0; i < n; i++) {
		int sum = 0;
		for (int j = 0; j < m; j++) {
			sum += arr[index];
			index++;
		}
		cout << sum << endl;
	}

	delete[]arr;
	return 0;
}
Cách 2: cấp phát động cho mảng 2 chiều.

Có thể thấy cách làm bên trên có 1 số hạn chế như bạn không thể truy xuất tới phần tử hàng i cột j của mảng arr bằng arr[i][j] (do arr là mảng 1 chiều) và code theo cách này cũng khá phức tạp.

Mảng 2 chiều được cấp phát động thực ra là mảng một chiều các con trỏ, và các con trỏ này trỏ tới phần tử đầu tiên của mảng được cấp phát động do đó cấp phát động cho mảng 2 chiều thực ra là cấp phát động cho nhiều mảng 1 chiều.

Cụ thể hơn là bạn sẽ dùng 1 con trỏ cấp 2 (con trỏ trỏ tới con trỏ), cấp phát cho nó n con trỏ cấp 1 (con trỏ cấp 1 là các con trỏ mà bạn vẫn hay dùng như int* p; // p là con trỏ cấp 1) và với mỗi con trỏ cấp 1 lại cấp phát m phần tử. Cụ thế hơn nếu làm với cách cấp phát động cho mảng 2 chiều thì sẽ như sau:

#include<iostream>

using namespace std;

int main() {
	int n, m;
	cin >> n >> m;

	// Khai báo con trỏ cấp 2 arr
	int** arr;

	// Cấp phát vùng nhớ động cho mảng 1 chiều các con trỏ kiểu int*
	// Có thể hiểu arr là mảng n phần tử, mỗi phần tử là 1 con trỏ kiểu int*
	arr = new int* [n];
	for (int i = 0; i < n; i++) {
		// Cấp phát động cho các n mảng 1 chiều
		arr[i] = new int[m];
	}

	// Nhập dữ liệu cho các phần tử trong mảng
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> arr[i][j];
		}
	}

	// Tính tổng từng hàng và hiển thị ra màn hình
	for (int i = 0; i < n; i++) {
		int sum = 0;
		for (int j = 0; j < m; j++) {
			sum += arr[i][j];
		}
		cout << sum << endl;
	}

	// Giải phóng bộ nhớ
	for (int i = 0; i < n; i++) {
		// Giải phóng bộ nhớ con các mảng một chiều
		delete[] arr[i];
	}
	// Giải phóng bộ nhớ cho mảng các con trỏ
	delete[]arr;
	return 0;
}
Lưu ý: Các phần tử của mảng 2 chiều được cấp phát động sẽ không nằm trên các ô nhớ liên tiếp. Xem ví dụ sau:

#include<iostream>

using namespace std;

int main() {
	int n = 3, m = 3;
	// Khai báo con trỏ cấp 2 arr
	int** arr;

	// Cấp phát vùng nhớ động cho mảng 1 chiều các con trỏ kiểu int*
	// Có thể hiểu arr là mảng n phần tử, mỗi phần tử là 1 con trỏ kiểu int*
	arr = new int* [n];
	for (int i = 0; i < n; i++) {
		// Cấp phát động cho các mảng 1 chiều
		arr[i] = new int[m];
	}

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cout << (int)&arr[i][j] << endl;
		}
	}

	// Giải phóng bộ nhớ
	for (int i = 0; i < n; i++) {
		// Giải phóng bộ nhớ con các mảng một chiều
		delete[] arr[i];
	}
	// Giải phóng bộ nhớ con mảng các con trỏ
	delete[]arr;
	return 0;
}
Kết quả khi chạy chươn trình:

9477304
9477308
9477312
9477808
9477812
9477816
9477360
9477364
9477368

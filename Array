Tên mảng (chính là biến arr trong bài này) mà từ trước tới nay bạn sử dụng có bản chất giống như một con trỏ. Để hiểu rõ hơn bạn có thể xem ví dụ sau:

#include <iostream>

using namespace std;

int main() {
    int arr[] = { 1, 2, 3, 4, 5 };
    // Hiển thị giá trị của arr
    cout << arr << endl;
    // Hiển thị địa chỉ của phần tử đầu tiên trong mảng
    cout << &arr[0];
    return 0;
}
Kết quả khi chạy chương trình

0039FA9C
0039FA9C
Có thể thấy giá trị của arr chính là địa chỉ của phần tử đầu tiên trong mảng (arr trỏ tới địa chỉ của arr[0]), nên có thể coi arr giống như 1 con trỏ.

Lưu ý: arr không phải là một con trỏ mà arr được dùng giống như một con trỏ.

Bạn có thể duyệt mảng bằng biến arr mà biến arr giống như một con trỏ nên bạn cũng có thể duyệt mảng bằng 1 con trỏ. Xem ví dụ sau:

#include <iostream>

using namespace std;

int main() {
    int arr[] = { 1, 2, 3, 4, 5 };
    int* p = &arr[0];
    for (int i = 0; i < 5; i++) {
        cout << p[i] << " ";
    }
    return 0;
}
Kết quả khi chạy chương trình:

1 2 3 4 5

------------------------------------------------------------
Mảng là một tập các phần tử được nằm trên các ô nhớ liên tiếp. Do đó địa chỉ của các phần tử trong mảng cũng liên tiếp nhau. Để hiểu rõ hơn bạn có thể xem chương trình sau:

#include <iostream>

using namespace std;

int main() {
	int arr[] = { 1, 2, 3, 4, 5 };
	for (int i = 0; i < 5; i++) {
		cout << (int)&arr[i] << " ";
	}
	return 0;
}
Kết quả khi chạy chương trình:

17824096 17824100 17824104 17824108 17824112
Kết quả khi chạy trên máy bạn sẽ khác nhưng nếu để ý thì bạn có thể thấy địa chỉ của các phần tử liên tiếp trong mảng luôn cách nhau 4 đơn vị (do kích thước của kiểu int là 4 byte nên 1 biến kiểu int sẽ cần dùng tới 4 ô nhớ để lưu dữ liệu)



Bạn hãy xem một ví dụ khác để hiểu rõ hơn:

#include <iostream>

using namespace std;

int main() {
	char arr[] = { 'a', 'b', 'c', 'd', 'e' };
	for (int i = 0; i < 5; i++) {
		cout << (int)&arr[i] << " ";
	}
	return 0;
}
Kết quả khi chạy chương trình:

12057624 12057625 12057626 12057627 12057628
Có thể thấy địa chỉ của các phần tử trong mảng cách nhau đúng 1 đơn vị (do kiểu char có kích thước là 1 byte nên chỉ cần 1 ô nhớ để lưu trữ dữ liệu).
------------------------------------------------------------
Để làm bài này bạn cần hiểu về toán tử + trên con trỏ. Đầu tiên bạn hãy chạy thử chương trình sau:

#include <iostream>

using namespace std;

int main() {
    // Khai báo mảng arr với 5 phần tử
    int arr[] = { 1, 2, 3, 4, 5 };
    // Cho con trỏ p trỏ tới phần tử đầu tiên của mảng
    int* p = &arr[0];
    // Hiển thị địa chỉ của phần tử đầu tiên trong arr
    cout << (int)&arr[0] << endl;
    for (int i = 0; i < 5; i++) {
        // Hiển thị giá trị khi cộng con trỏ p với i
        cout << (int)(p + i) << " ";
    }
    return 0;
}
Kết quả khi chạy chương trình:

3799772
3799772 3799776 3799780 3799784 3799788
Từ kết quả trên có thể nhận xét rằng:

Kết quả của phép cộng một con trỏ với 1 giá trị là 1 con trỏ trỏ tới ô nhớ khác (p trỏ tới ô nhớ 3799772, p + 1 trỏ tới ô nhớ 3799776).
p + 1 trỏ tới ô nhớ cách ô nhớ mà p trỏ tới 4 địa chỉ (do p là con trỏ kiểu int và kích thước của kiểu int là 4 byte).
p + 2 trỏ tới ô nhớ cách ô nhớ mà p trỏ tới 8 địa chỉ.
p + 3 trỏ tới ô nhớ cách ô nhớ mà p trỏ tới 12 địa chỉ.
p + 4 trỏ tới ô nhớ cách ô nhớ mà p trỏ tới 16 địa chỉ.
Như bài trước bạn đã được học, địa chỉ của các phần tử liên tiếp trong mảng số nguyên luôn cách nhau 4 đơn vị nên bạn cũng có thể duyệt mảng sử dụng con trỏ với toán tử + như sau:

#include <iostream>

using namespace std;

int main() {
    int arr[] = { 1, 2, 3, 4, 5 };
    int* p = &arr[0];
    for (int i = 0; i < 5; i++) {
        cout << *(p + i) << " ";
    }
    return 0;
}
Kết quả khi chạy chương trình

1 2 3 4 5
Có thể thấy khi cộng con trỏ với 1 giá_trị thì kết quả sẽ là một con trỏ trỏ tới ô nhớ cách đó sizeof(kiểu_con_trỏ) * giá_trị. Xem ví dụ với con trỏ kiểu double* để hiểu rõ hơn:

#include <iostream>

using namespace std;

int main() {
    double arr[] = { 1.5, 2.5, 3.5, 4.5, 5.5 };
    double* p = &arr[0]; // Bạn còn có thể viết double * p = arr;
    for (int i = 0; i < 5; i++) {
        cout << (int)(p + i) << " ";
    }
    return 0;
}
Kết quả khi chạy chương trình:

9895220 9895228 9895236 9895244 9895252
Có thể thấy p + 1 cách p 8 địa chỉ, p + 2 cách p 16 địa chỉ, ... (do sizeof(double) = 8)

-----------------------------------------------------------------------------------------
Trước hết bạn hãy xem lại cách khai báo mảng thông thường:

// Khai báo mảng a 100 phần tử
int arr[100];
Nhược điểm:

Với cách khai báo này số phần tử của mảng luôn phải cố định, bạn không thể thay đổi kích thước của mảng khi chương trình đang chạy. Ví dụ vì lý do nào đó mà sau này mảng arr cần tới 101 phần tử thì bạn chỉ có cách tắt chương trình đi và code lại thành int arr[101]; (do mảng không tự tăng kích thước được).
Mảng sẽ được cấp phát trên vùng nhớ Stack, và kích thước của vùng nhớ này là nhỏ nên bạn không thể khai báo mảng có nhiều phần tử được. Ví dụ bạn hãy thử chạy chương trình sau:
#include <iostream>

using namespace std;

int main() {
    int arr[10000000];
    return 0;
}
​
Chương trình này sẽ báo lỗi do kích thước của vùng nhớ Stack không đủ để cấp phát bộ nhớ cho mảng a.

Ưu điểm:

Mảng được cấp phát trên vùng nhớ Stack nên sẽ có tốc độ truy xuất nhanh (vùng nhớ stack tuy có kích thước nhỏ nhưng lại có tốc độ truy xuất nhanh hơn các vùng nhớ khác).
Bộ nhớ được chương trình quản lý tự động (vùng nhớ được cấp phát cho mảng sẽ được chương trình giải phóng khi không dùng nữa).
Mảng được cấp phát động sẽ giải quyết được những nhược điểm trên nhưng cũng có một số nhược điểm. Trước hết bạn hãy xem cách để cấp phát bộ nhớ động cho mảng:

// Cấp phát bộ nhớ động cho mảng có 10000000 phần tử
// Để cấp phát bộ nhớ động cho mảng ta sử dụng toán tử new
int* arr = new int[10000000];
Đoạn code trên cấp phát bộ nhớ động cho mảng có 10000000 phần tử, lưu ý rằng arr không phải là một mảng, arr là một con trỏ trỏ tới vùng nhớ được cấp phát động (trỏ tới phần tử đầu tiên của mảng được cấp phát động) hay hiểu cách khác arr là con trỏ dùng để quản lý mảng có 10000000 phần tử.

Bạn có thể sử dụng mảng được cấp phát động giống như mảng thông thường:

#include <iostream>

using namespace std;

int main() {
    // Cấp phát động cho mảng có 10 phần tử
    int* arr = new int[10];
    for (int i = 0; i < 10; i++) {
        arr[i] = i;
    }
    for (int i = 0; i < 10; i++) {
        cout << arr[i] << " ";
    }
    // Giải phóng bộ nhớ được cấp phát động khi không sử dụng
    delete[]arr;
    return 0;
}
Kết quả khi chạy chương trình:

0 1 2 3 4 5 6 7 8 9
Ưu điểm của cấp phát bộ nhớ động

Số phần tử của mảng không nhất thiết phải cố định. Ví dụ:
#include <iostream>

using namespace std;

int main() {
    int n;
    cin >> n;
    // Cấp phát động cho mảng có n phần tử
    int* arr = new int[n];
    // Giải phóng bộ nhớ được cấp phát động khi không sử dụng
    delete[]arr;
    return 0;
}
​​
Có thể thấy trong ví dụ trên số phần tử của mảng được cấp phát động là một biến được nhập từ bàn phím.

Bạn có thể thay đổi kích thước mảng khi chương trình đang chạy (bản chất là cho con trỏ tới vùng nhớ khác, ví dụ nếu bạn cần tăng kích thước của mảng thì bạn chỉ cần cho con trỏ trỏ tới vùng nhớ có kích thước lớn hơn).
Mảng được cấp phát trên vùng nhớ Heap mà vùng nhớ Heap là vùng nhớ có kích thước lớn nhất trong các vùng nhớ nên với cấp phát động bạn có thể khai báo mảng với nhiều phần tử. Ví dụ:
#include <iostream>

using namespace std;

int main() {
    int* arr = new int[10000000];
    // Giải phóng bộ nhớ được cấp phát động khi không sử dụng
    delete[]arr;
    return 0;
}
​
Chương trình này khi chạy sẽ không báo lỗi do vùng nhớ Heap có kích thước lớn và có thể lưu trữ được mảng có 10000000 phần tử.
Nhược điểm của cấp phát bộ nhớ động

Vùng nhớ Heap có tốc độ truy xuất chậm hơn vùng nhớ Stack nên việc truy xuất vào các phần tử trong mảng được cấp phát động sẽ chậm hơn.
Bạn phải tự quản lý bộ nhớ được cấp phát động (chương trình sẽ không quản lý cho bạn). Nếu bạn thực hiện cấp phát bộ nhớ động mà không giải phóng thì vùng nhớ này sẽ vẫn còn cho tới khi khởi động lại máy (gây lãng phí bộ nhớ, tệ hơn nữa là tràn bộ nhớ).
Để giải phóng bộ nhớ được cấp phát động bạn dùng toán tử delete[]. Ví dụ:

#include <iostream>

using namespace std;

int main() {
	// Cấp phát bộ nhớ động cho mảng có 1000 phần tử
	int* arr = new int[1000];
	...
	// Giải phòng bộ nhớ khi không dùng tới
	delete[] arr;
	return 0;
}
​​
Do đó khi cấp phát động hãy luôn nhớ phải dùng toán tử delete[] để giải phóng bộ nhớ khi không dùng tới nữa.

Lỗi thường gặp khi cấp phát bộ nhớ động:

#include<iostream>

using namespace std;

int main() {
	int* arr = new int[1000];
	arr = new int[2000];
	delete[]arr;
	return 0;
}
Đoạn code trên sẽ gây ra rò rỉ bộ nhớ do khi gán arr = new int[2000]; thì vùng nhớ được cấp phát động cho mảng có 1000 phần tử vẫn còn đó, bạn cần giải phóng vùng nhớ này trước khi cho arr trỏ tới vùng nhớ mới giống như sau:

#include<iostream>

using namespace std;

int main() {
	int* arr = new int[1000];
	delete[]arr;
	arr = new int[2000];
	delete[]arr;
	return 0;
}
